{:functions ({:args [{:spelling "options", :type "struct usearch_init_options_t *"} {:spelling "error", :type "const char **"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clong/usearch_init_options_t] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_init", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_init, :raw-comment "/**\n *  @brief Initializes a new instance of the index.\n *  @param options Pointer to the `usearch_init_options_t` structure containing initialization options.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n *  @return A handle to the initialized USearch index, or `NULL` on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_init"} {:args [{:spelling "", :type "void *"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_free, :raw-comment "/**\n *  @brief Frees the resources associated with the index.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_free"} {:args [{:spelling "", :type "void *"} {:spelling "error", :type "const char **"}], :ret {:spelling "unsigned long"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_serialized_length", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_serialized_length, :raw-comment "/**\n *  @brief Reports expected file size after serialization.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_serialized_length"} {:args [{:spelling "", :type "void *"} {:spelling "path", :type "const char *"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_save", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_save, :raw-comment "/**\n *  @brief Saves the index to a file.\n *  @param[in] path The file path where the index will be saved.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_save"} {:args [{:spelling "", :type "void *"} {:spelling "path", :type "const char *"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_load", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_load, :raw-comment "/**\n *  @brief Loads the index from a file.\n *  @param[in] path The file path from where the index will be loaded.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_load"} {:args [{:spelling "", :type "void *"} {:spelling "path", :type "const char *"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_view", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_view, :raw-comment "/**\n *  @brief Creates a view of the index from a file without copying it into memory.\n *  @param[in] path The file path from where the view will be created.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_view"} {:args [{:spelling "path", :type "const char *"} {:spelling "options", :type "struct usearch_init_options_t *"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/usearch_init_options_t] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_metadata", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_metadata, :raw-comment "/**\n *  @brief Loads index metadata from a file.\n *  @param[in] path The file path from where the index will be loaded.\n *  @param[out] options Pointer to the `usearch_init_options_t` structure to be populated.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n *  @return A handle to the initialized USearch index, or `NULL` on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_metadata"} {:args [{:spelling "", :type "void *"} {:spelling "buffer", :type "void *"} {:spelling "length", :type "unsigned long"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/long [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_save_buffer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_save_buffer, :raw-comment "/**\n *  @brief Saves the index to an in-memory buffer.\n *  @param[in] buffer The in-memory continuous buffer where the index will be saved.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_save_buffer"} {:args [{:spelling "", :type "void *"} {:spelling "buffer", :type "const void *"} {:spelling "length", :type "unsigned long"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/long [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_load_buffer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_load_buffer, :raw-comment "/**\n *  @brief Loads the index from an in-memory buffer.\n *  @param[in] buffer The in-memory continuous buffer from where the index will be loaded.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_load_buffer"} {:args [{:spelling "", :type "void *"} {:spelling "buffer", :type "const void *"} {:spelling "length", :type "unsigned long"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/long [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_view_buffer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_view_buffer, :raw-comment "/**\n *  @brief Creates a view of the index from an in-memory buffer without copying it into memory.\n *  @param[in] buffer The in-memory continuous buffer from where the view will be created.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_view_buffer"} {:args [{:spelling "buffer", :type "const void *"} {:spelling "length", :type "unsigned long"} {:spelling "options", :type "struct usearch_init_options_t *"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/long [:coffi.mem/pointer :clong/usearch_init_options_t] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_metadata_buffer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_metadata_buffer, :raw-comment "/**\n *  @brief Loads index metadata from an in-memory buffer.\n *  @param[in] path The file path from where the index will be loaded.\n *  @param[out] options Pointer to the `usearch_init_options_t` structure to be populated.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n *  @return A handle to the initialized USearch index, or `NULL` on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_metadata_buffer"} {:args [{:spelling "", :type "void *"} {:spelling "error", :type "const char **"}], :ret {:spelling "unsigned long"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_size", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_size, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "usearch_size"} {:args [{:spelling "", :type "void *"} {:spelling "error", :type "const char **"}], :ret {:spelling "unsigned long"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_capacity", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_capacity, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "usearch_capacity"} {:args [{:spelling "", :type "void *"} {:spelling "error", :type "const char **"}], :ret {:spelling "unsigned long"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_dimensions", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_dimensions, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "usearch_dimensions"} {:args [{:spelling "", :type "void *"} {:spelling "error", :type "const char **"}], :ret {:spelling "unsigned long"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_connectivity", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_connectivity, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "usearch_connectivity"} {:args [{:spelling "", :type "void *"} {:spelling "capacity", :type "unsigned long"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/long [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_reserve", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_reserve, :raw-comment "/**\n *  @brief Reserves memory for a specified number of incoming vectors.\n *  @param[in] capacity The desired total capacity including current size.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_reserve"} {:args [{:spelling "", :type "void *"} {:spelling "key", :type "unsigned long long"} {:spelling "vector", :type "const void *"} {:spelling "vector_kind", :type "enum usearch_scalar_kind_t"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/long :coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_add", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_add, :raw-comment "/**\n *  @brief Adds a vector with a key to the index.\n *  @param[in] key The key associated with the vector.\n *  @param[in] vector Pointer to the vector data.\n *  @param[in] vector_kind The scalar type used in the vector data.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_add"} {:args [{:spelling "", :type "void *"} {:spelling "", :type "unsigned long long"} {:spelling "error", :type "const char **"}], :ret {:spelling "_Bool"}, :function/args [:coffi.mem/pointer :coffi.mem/long [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_contains", :function/ret :coffi.mem/char, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_contains, :raw-comment "/**\n *  @brief Checks if the index contains a vector with a specific key.\n *  @param[in] key The key to be checked.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n *  @return `true` if the index contains the vector with the given key, `false` otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_contains"} {:args [{:spelling "", :type "void *"} {:spelling "", :type "unsigned long long"} {:spelling "error", :type "const char **"}], :ret {:spelling "unsigned long"}, :function/args [:coffi.mem/pointer :coffi.mem/long [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_count", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_count, :raw-comment "/**\n *  @brief Counts the number of entries in the index under a specific key.\n *  @param[in] key The key to be checked.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n *  @return Number of vectors found under that key.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_count"} {:args [{:spelling "", :type "void *"} {:spelling "query_vector", :type "const void *"} {:spelling "query_kind", :type "enum usearch_scalar_kind_t"} {:spelling "count", :type "unsigned long"} {:spelling "keys", :type "unsigned long long *"} {:spelling "distances", :type "float *"} {:spelling "error", :type "const char **"}], :ret {:spelling "unsigned long"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/int :coffi.mem/long [:coffi.mem/pointer :coffi.mem/long] [:coffi.mem/pointer :coffi.mem/float] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_search", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_search, :raw-comment "/**\n *  @brief Performs k-Approximate Nearest Neighbors (kANN) Search for closest vectors to query.\n *  @param[in] query_vector Pointer to the query vector data.\n *  @param[in] query_kind The scalar type used in the query vector data.\n *  @param[in] count Upper bound on the number of neighbors to search, the \"k\" in \"kANN\".\n *  @param[out] keys Output buffer for up to `count` nearest neighbors keys.\n *  @param[out] distances Output buffer for up to `count` distances to nearest neighbors.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n *  @return Number of found matches.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_search"} {:args [{:spelling "", :type "void *"} {:spelling "key", :type "unsigned long long"} {:spelling "count", :type "unsigned long"} {:spelling "vector", :type "void *"} {:spelling "vector_kind", :type "enum usearch_scalar_kind_t"} {:spelling "error", :type "const char **"}], :ret {:spelling "unsigned long"}, :function/args [:coffi.mem/pointer :coffi.mem/long :coffi.mem/long :coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_get", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_get, :raw-comment "/**\n *  @brief Retrieves the vector associated with the given key from the index.\n *  @param[in] key The key of the vector to retrieve.\n *  @param[out] vector Pointer to the memory where the vector data will be copied.\n *  @param[in] count Number of vectors that can be fitted into `vector` for multi-vector entries.\n *  @param[in] vector_kind The scalar type used in the vector data.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n *  @return Number of vectors found under that name and exported to `vector`.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_get"} {:args [{:spelling "", :type "void *"} {:spelling "key", :type "unsigned long long"} {:spelling "error", :type "const char **"}], :ret {:spelling "unsigned long"}, :function/args [:coffi.mem/pointer :coffi.mem/long [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_remove", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_remove, :raw-comment "/**\n *  @brief Removes the vector associated with the given key from the index.\n *  @param[in] key The key of the vector to be removed.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n *  @return Number of vectors found under that name and dropped from the index.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_remove"} {:args [{:spelling "", :type "void *"} {:spelling "from", :type "unsigned long long"} {:spelling "to", :type "unsigned long long"} {:spelling "error", :type "const char **"}], :ret {:spelling "unsigned long"}, :function/args [:coffi.mem/pointer :coffi.mem/long :coffi.mem/long [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_rename", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_rename, :raw-comment "/**\n *  @brief Renames the vector to map to a different key.\n *  @param[in] from The key of the vector to be renamed.\n *  @param[in] to New key for found entry.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n *  @return Number of vectors found under that name and renamed.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_rename"} {:args [{:spelling "vector_first", :type "const void *"} {:spelling "vector_second", :type "const void *"} {:spelling "scalar_kind", :type "enum usearch_scalar_kind_t"} {:spelling "dimensions", :type "unsigned long"} {:spelling "metric_kind", :type "enum usearch_metric_kind_t"} {:spelling "error", :type "const char **"}], :ret {:spelling "float"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/int :coffi.mem/long :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_distance", :function/ret :coffi.mem/float, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_distance, :raw-comment "/**\n *  @brief Computes the distance between two equi-dimensional vectors.\n *  @param[in] vector_first The first vector for comparison.\n *  @param[in] vector_second The second vector for comparison.\n *  @param[in] scalar_kind The scalar type used in the vectors.\n *  @param[in] dimensions The number of dimensions in each vector.\n *  @param[in] metric_kind The metric kind used for distance calculation between vectors.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n *  @return Distance between given vectors.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_distance"} {:args [{:spelling "dataset", :type "const void *"} {:spelling "dataset_size", :type "unsigned long"} {:spelling "dataset_stride", :type "unsigned long"} {:spelling "queries", :type "const void *"} {:spelling "queries_size", :type "unsigned long"} {:spelling "queries_stride", :type "unsigned long"} {:spelling "scalar_kind", :type "enum usearch_scalar_kind_t"} {:spelling "dimensions", :type "unsigned long"} {:spelling "metric_kind", :type "enum usearch_metric_kind_t"} {:spelling "count", :type "unsigned long"} {:spelling "threads", :type "unsigned long"} {:spelling "keys", :type "unsigned long long *"} {:spelling "keys_stride", :type "unsigned long"} {:spelling "distances", :type "float *"} {:spelling "distances_stride", :type "unsigned long"} {:spelling "error", :type "const char **"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/long :coffi.mem/long :coffi.mem/pointer :coffi.mem/long :coffi.mem/long :coffi.mem/int :coffi.mem/long :coffi.mem/int :coffi.mem/long :coffi.mem/long [:coffi.mem/pointer :coffi.mem/long] :coffi.mem/long [:coffi.mem/pointer :coffi.mem/float] :coffi.mem/long [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "usearch_exact_search", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :usearch_exact_search, :raw-comment "/**\n *  @brief Multi-threaded exact nearest neighbors search for equi-dimensional vectors.\n *  @param[in] dataset Pointer to the first scalar of the dataset matrix.\n *  @param[in] queries Pointer to the first scalar of the queries matrix.\n *  @param[in] dataset_size Number of vectors in the `dataset`.\n *  @param[in] queries_size Number of vectors in the `queries` set.\n *  @param[in] dataset_stride Number of bytes between starts of consecutive vectors in `dataset`.\n *  @param[in] queries_stride Number of bytes between starts of consecutive vectors in `queries`.\n *  @param[in] scalar_kind The scalar type used in the vectors.\n *  @param[in] dimensions The number of dimensions in each vector.\n *  @param[in] metric_kind The metric kind used for distance calculation between vectors.\n *  @param[in] count Upper bound on the number of neighbors to search, the \"k\" in \"kANN\".\n *  @param[in] threads Upper bound for the number of CPU threads to use.\n *  @param[out] keys Output buffer for up to `count` nearest neighbors keys.\n *  @param[out] distances Output buffer for up to `count` distances to nearest neighbors.\n *  @param[out] error Pointer to a string where the error message will be stored, if an error occurs.\n *  @return Number of found matches.\n */", :kind "CXCursor_FunctionDecl", :spelling "usearch_exact_search"}), :structs ({:kind "CXCursor_StructDecl", :spelling "struct usearch_init_options_t", :type "CXType_Record", :id :clong/usearch_init_options_t, :size-in-bytes 64, :fields [{:type "enum usearch_metric_kind_t", :datatype :coffi.mem/int, :name "metric_kind", :bitfield? false, :calculated-offset 0} {:type "float (*)(const void *, const void *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/float], :name "metric", :bitfield? false, :calculated-offset 64} {:type "enum usearch_scalar_kind_t", :datatype :coffi.mem/int, :name "quantization", :bitfield? false, :calculated-offset 128} {:type "unsigned long", :datatype :coffi.mem/long, :name "dimensions", :bitfield? false, :calculated-offset 192} {:type "unsigned long", :datatype :coffi.mem/long, :name "connectivity", :bitfield? false, :calculated-offset 256} {:type "unsigned long", :datatype :coffi.mem/long, :name "expansion_add", :bitfield? false, :calculated-offset 320} {:type "unsigned long", :datatype :coffi.mem/long, :name "expansion_search", :bitfield? false, :calculated-offset 384} {:type "_Bool", :datatype :coffi.mem/char, :name "multi", :bitfield? false, :calculated-offset 448}]}), :enums ({:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_unknown_k", :type "CXType_Int", :name "usearch_metric_unknown_k", :value 0, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_cos_k", :type "CXType_Int", :name "usearch_metric_cos_k", :value 1, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_ip_k", :type "CXType_Int", :name "usearch_metric_ip_k", :value 2, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_l2sq_k", :type "CXType_Int", :name "usearch_metric_l2sq_k", :value 3, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_haversine_k", :type "CXType_Int", :name "usearch_metric_haversine_k", :value 4, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_divergence_k", :type "CXType_Int", :name "usearch_metric_divergence_k", :value 5, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_pearson_k", :type "CXType_Int", :name "usearch_metric_pearson_k", :value 6, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_jaccard_k", :type "CXType_Int", :name "usearch_metric_jaccard_k", :value 7, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_hamming_k", :type "CXType_Int", :name "usearch_metric_hamming_k", :value 8, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_tanimoto_k", :type "CXType_Int", :name "usearch_metric_tanimoto_k", :value 9, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_sorensen_k", :type "CXType_Int", :name "usearch_metric_sorensen_k", :value 10, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_unknown_k", :type "CXType_Int", :name "usearch_metric_unknown_k", :value 0, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_cos_k", :type "CXType_Int", :name "usearch_metric_cos_k", :value 1, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_ip_k", :type "CXType_Int", :name "usearch_metric_ip_k", :value 2, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_l2sq_k", :type "CXType_Int", :name "usearch_metric_l2sq_k", :value 3, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_haversine_k", :type "CXType_Int", :name "usearch_metric_haversine_k", :value 4, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_divergence_k", :type "CXType_Int", :name "usearch_metric_divergence_k", :value 5, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_pearson_k", :type "CXType_Int", :name "usearch_metric_pearson_k", :value 6, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_jaccard_k", :type "CXType_Int", :name "usearch_metric_jaccard_k", :value 7, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_hamming_k", :type "CXType_Int", :name "usearch_metric_hamming_k", :value 8, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_tanimoto_k", :type "CXType_Int", :name "usearch_metric_tanimoto_k", :value 9, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_metric_sorensen_k", :type "CXType_Int", :name "usearch_metric_sorensen_k", :value 10, :enum "usearch_metric_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_unknown_k", :type "CXType_Int", :name "usearch_scalar_unknown_k", :value 0, :enum "usearch_scalar_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_f32_k", :type "CXType_Int", :name "usearch_scalar_f32_k", :value 1, :enum "usearch_scalar_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_f64_k", :type "CXType_Int", :name "usearch_scalar_f64_k", :value 2, :enum "usearch_scalar_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_f16_k", :type "CXType_Int", :name "usearch_scalar_f16_k", :value 3, :enum "usearch_scalar_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_i8_k", :type "CXType_Int", :name "usearch_scalar_i8_k", :value 4, :enum "usearch_scalar_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_b1_k", :type "CXType_Int", :name "usearch_scalar_b1_k", :value 5, :enum "usearch_scalar_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_unknown_k", :type "CXType_Int", :name "usearch_scalar_unknown_k", :value 0, :enum "usearch_scalar_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_f32_k", :type "CXType_Int", :name "usearch_scalar_f32_k", :value 1, :enum "usearch_scalar_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_f64_k", :type "CXType_Int", :name "usearch_scalar_f64_k", :value 2, :enum "usearch_scalar_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_f16_k", :type "CXType_Int", :name "usearch_scalar_f16_k", :value 3, :enum "usearch_scalar_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_i8_k", :type "CXType_Int", :name "usearch_scalar_i8_k", :value 4, :enum "usearch_scalar_kind_t", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "usearch_scalar_b1_k", :type "CXType_Int", :name "usearch_scalar_b1_k", :value 5, :enum "usearch_scalar_kind_t", :raw-comment nil})}